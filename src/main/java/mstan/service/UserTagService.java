package mstan.service;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.time.Instant;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.atomic.AtomicInteger;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;

import mstan.domain.Action;
import mstan.domain.Device;
import mstan.domain.Product;
import mstan.domain.TimeRange;
import mstan.domain.UserProfileResult;
import mstan.domain.UserTagEntry;
import mstan.domain.UserTagEvent;

/*
SQL TABLE:

       Column        |            Type             | Collation | Nullable |             Default
---------------------+-----------------------------+-----------+----------+----------------------------------
 id                  | integer                     |           | not null | generated by default as identity
 action              | integer                     |           |          |
 cookie              | character varying(255)      |           |          |
 country             | character varying(255)      |           |          |
 device              | integer                     |           |          |
 origin              | character varying(255)      |           |          |
 product_brand_id    | character varying(255)      |           |          |
 product_category_id | character varying(255)      |           |          |
 product_id          | integer                     |           | not null |
 product_price       | integer                     |           | not null |
 time                | timestamp without time zone |           |          |
Indexes:
    "user_tag_pkey" PRIMARY KEY, btree (id)
 */

@Service
public class UserTagService {

    private static final Logger log = LoggerFactory.getLogger(UserTagService.class);

    private Connection conn;

    private final int kMaxLimit = 200;

    private final Map<EventKey, AtomicInteger> count = new HashMap<>();
    // private final Map<Filters, Stats> stats = new HashMap<>();

    public UserTagService() throws SQLException {
        try {
            String url = "jdbc:postgresql://localhost:5000/postgres?user=postgres&password=postgres";
            this.conn = DriverManager.getConnection(url);
        } catch (SQLException e) {
            log.error("Could not connect to the database");
            log.error("Could not initialize SQL query");
            log.error("Could not initialize SQL query");
        }
    }

    private void addToDatabase(UserTagEvent event) {
        String sql = "INSERT INTO user_tag (time, cookie, country, device, action, origin, " +
                     "product_id, product_brand_id, product_category_id, product_price) " +
                     "VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
        try {
            PreparedStatement pstmt = conn.prepareStatement(sql);
            pstmt.setTimestamp(1, java.sql.Timestamp.from(event.getTime()));
            pstmt.setString(2, event.getCookie());
            pstmt.setString(3, event.getCountry());
            pstmt.setInt(4, event.getDevice().ordinal());
            pstmt.setInt(5, event.getAction().ordinal());
            pstmt.setString(6, event.getOrigin());
            pstmt.setInt(7, event.getProductInfo().getProductId());
            pstmt.setString(8, event.getProductInfo().getBrandId());
            pstmt.setString(9, event.getProductInfo().getCategoryId());
            pstmt.setInt(10, event.getProductInfo().getPrice());
            pstmt.executeUpdate();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    @Async
    public void registerEvent(UserTagEvent event) {
        log.info("event: " + event);
        addToDatabase(event);
        // UserTagEntry entry = new UserTagEntry();
        // entry.fromEvent(event);

        // EventKey key = new EventKey(event.getCookie(), event.getAction());
        // if (!count.containsKey(key)) {
        //     count.put(key, new AtomicInteger(0));
        // }

        // List<Filters> allFilters = Filters.allFilters(
        //     event.getAction(),
        //     event.getCookie(),
        //     event.getProductInfo().getBrandId(),
        //     event.getProductInfo().getCategoryId()
        // );

        // for (Filters f : allFilters) {
        //     if (stats.containsKey(f)) {
        //         stats.put(f, new Stats());
        //     }

        //     stats.get(f).updateWith(event.getProductInfo().getPrice());
        // }

        // if (count.get(key).incrementAndGet() % kMaxLimit == 0) {
        //     cleanupEvents(event.getCookie(), event.getAction());
        // }
    }

    public void cleanupEvents(String cookie, Action action) {
        // UserTagEntry entry = this.userTagRepository.findOutdatedEntryByCookieAction(cookie, action.ordinal());
        // if (entry != null) {
        //     System.err.println("cleaning up entries for cookie: " + cookie + " action: " + action.name());
        //     this.userTagRepository.deleteOutdatedEntriesByCookieAction(cookie, action.ordinal(), entry.getTime());
        // }
    }

    private static Device[] deviceValues = Device.values();
    private static Action[] actionValues = Action.values();

    // Method to find user tags by cookie, action, and time range
    public List<UserTagEvent> findByCookieActionAndTimeBetween(String cookie, int action, Instant start, Instant end, int limit) {
        String sql = "SELECT * FROM user_tag WHERE cookie = ? AND action = ? " +
                     "AND time >= ? AND time < ? ORDER BY time DESC LIMIT ?";

        List<UserTagEvent> userTagEntries = new ArrayList<>();
        try {
            PreparedStatement pstmt = conn.prepareStatement(sql);
            pstmt.setString(1, cookie);
            pstmt.setInt(2, action);
            pstmt.setTimestamp(3, java.sql.Timestamp.from(start));
            pstmt.setTimestamp(4, java.sql.Timestamp.from(end));
            pstmt.setInt(5, limit);

            ResultSet rs = pstmt.executeQuery();
            while (rs.next()) {
                Product productInfo = new Product();
                productInfo.setProductId(rs.getInt("product_id"));
                productInfo.setBrandId(rs.getString("product_brand_id"));
                productInfo.setCategoryId(rs.getString("product_category_id"));
                productInfo.setPrice(rs.getInt("product_price"));
                UserTagEvent event = new UserTagEvent(
                    rs.getTimestamp("time").toInstant(),
                    rs.getString("cookie"),
                    rs.getString("country"),
                    deviceValues[rs.getInt("device")],
                    actionValues[rs.getInt("action")],
                    rs.getString("origin"),
                    productInfo
                );
                userTagEntries.add(event);
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }

        return userTagEntries;
    }

    public UserProfileResult findUserProfiles(String cookie, TimeRange range, int limit) {
        return new UserProfileResult(
            cookie,
            findByCookieActionAndTimeBetween(cookie, Action.VIEW.ordinal(), range.getBegin(), range.getEnd(), limit),
            findByCookieActionAndTimeBetween(cookie, Action.BUY.ordinal(), range.getBegin(), range.getEnd(), limit)
        );
    }

}
